<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Practical Machine Learning Peer Assessment</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Practical Machine Learning Peer Assessment</h1>

<h2>Summary</h2>

<p>This analysis was done to predict the manner in which the subjects performed weight lifting exercises. The data is collected from accelerometers on the belt, forearm, arm, and dumbell of 6 participants. The outcome variable has five classes and the total number of predictors are 159.</p>

<h2>Getting and preparing the data</h2>

<p>We load the training and testing data sets. Here it was necessary to pay attention to the fact that missing values could be represented in several ways, either by an NA, a totally empty value or #DIV/0! indicating a divide by zero error. </p>

<p>Examining the dataset, there are id columns x, some timestamp etc which are not useful for model fitting. We removed those as well.</p>

<p>There are 159 variables. But many of them are missing values for most of the records. I removed them as well.</p>

<pre><code class="r">## downloading data from URL
Train_URL &lt;- &quot;https://d396qusza40orc.cloudfront.net/predmachlearn/pml-training.csv&quot;
Test_URL &lt;- &quot;https://d396qusza40orc.cloudfront.net/predmachlearn/pml-testing.csv&quot;
download.file(url=Train_URL, destfile=&quot;pml-training.csv&quot;,method = &quot;curl&quot;)
</code></pre>

<pre><code>## Warning: running command &#39;curl
## &quot;https://d396qusza40orc.cloudfront.net/predmachlearn/pml-training.csv&quot; -o
## &quot;pml-training.csv&quot;&#39; had status 127
</code></pre>

<pre><code>## Warning in download.file(url = Train_URL, destfile = &quot;pml-training.csv&quot;, :
## download had nonzero exit status
</code></pre>

<pre><code class="r">download.file(url=Test_URL, destfile=&quot;pml-testing.csv&quot;)
##reading data
Train &lt;- read.csv(&quot;pml-training.csv&quot;,row.names=1,na.strings = c(&quot;&quot;,&quot;NA&quot;, &quot;#DIV/0!&quot;))
</code></pre>

<pre><code>## Warning in file(file, &quot;rt&quot;): cannot open file &#39;pml-training.csv&#39;: No such
## file or directory
</code></pre>

<pre><code>## Error in file(file, &quot;rt&quot;): cannot open the connection
</code></pre>

<pre><code class="r">Test &lt;- read.csv(&quot;pml-testing.csv&quot;,row.names=1,na.strings = c(&quot;NA&quot;,&quot;&quot;, &quot;#DIV/0!&quot;))


## remmving some varables which are not required
ColsToDrp &lt;- c (&quot;user_name&quot;, &quot;raw_timestamp_part_1&quot;, &quot;raw_timestamp_part_2&quot;, &quot;cvtd_timestamp&quot;, &quot;X&quot;, &quot;new_window&quot;)
Training &lt;- Train[,!(names(Train) %in% ColsToDrp )]
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;Train&#39; not found
</code></pre>

<pre><code class="r">Testing &lt;- Test[,!(names(Test) %in% ColsToDrp)]

## removing variables which has many missing values
NoOfCols &lt;- dim(Training)[2]
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;Training&#39; not found
</code></pre>

<pre><code class="r">ColsWithMissingData &lt;- vector(length=NoOfCols)
</code></pre>

<pre><code>## Error in vector(length = NoOfCols): object &#39;NoOfCols&#39; not found
</code></pre>

<pre><code class="r">for (i in 1:NoOfCols) { ColsWithMissingData[i] &lt;- sum(is.na(Training[,i]))}
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;NoOfCols&#39; not found
</code></pre>

<pre><code class="r">Training &lt;- Training[,which(ColsWithMissingData  &lt; 5)]
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;Training&#39; not found
</code></pre>

<pre><code class="r">Testing &lt;- Testing[,which(ColsWithMissingData  &lt; 5)]
</code></pre>

<pre><code>## Error in which(ColsWithMissingData &lt; 5): object &#39;ColsWithMissingData&#39; not found
</code></pre>

<pre><code class="r">dim(Training)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;Training&#39; not found
</code></pre>

<pre><code class="r">dim(Testing)
</code></pre>

<pre><code>## [1]  20 154
</code></pre>

<p>we subdivide the training set to create a cross validation set. We allocate 70% of the original training set to the new training set, and the other 30% to the cross validation set:</p>

<pre><code class="r">library(caret)
</code></pre>

<pre><code>## Warning: package &#39;caret&#39; was built under R version 3.1.2
</code></pre>

<pre><code>## Loading required package: lattice
## Loading required package: ggplot2
</code></pre>

<pre><code class="r">inTrain &lt;- createDataPartition(y=Training$classe, p=0.7, list=FALSE)
</code></pre>

<pre><code>## Error in createDataPartition(y = Training$classe, p = 0.7, list = FALSE): object &#39;Training&#39; not found
</code></pre>

<pre><code class="r">Training &lt;- Training[inTrain,]
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;Training&#39; not found
</code></pre>

<pre><code class="r">TrainingTest &lt;- Training[-inTrain,]
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;Training&#39; not found
</code></pre>

<h2>Linear Regression</h2>

<p>In the new training and validation set, there are 53 predictors and 1 response. I check the correlations between the predictors and the outcome variable in the new training set. There doesn’t seem to be any predictors strongly correlated with the outcome variable, so linear regression model may not be a good option. We will check other models for better fit.</p>

<pre><code class="r">cor &lt;- abs(sapply(colnames(Training[, -ncol(Training)]), function(x) cor(as.numeric(Training[, x]), as.numeric(Training$classe), method = &quot;spearman&quot;)))
</code></pre>

<pre><code>## Error in is.data.frame(x): object &#39;Training&#39; not found
</code></pre>

<pre><code class="r">cor
</code></pre>

<pre><code>## function (x, y = NULL, use = &quot;everything&quot;, method = c(&quot;pearson&quot;, 
##     &quot;kendall&quot;, &quot;spearman&quot;)) 
## {
##     na.method &lt;- pmatch(use, c(&quot;all.obs&quot;, &quot;complete.obs&quot;, &quot;pairwise.complete.obs&quot;, 
##         &quot;everything&quot;, &quot;na.or.complete&quot;))
##     if (is.na(na.method)) 
##         stop(&quot;invalid &#39;use&#39; argument&quot;)
##     method &lt;- match.arg(method)
##     if (is.data.frame(y)) 
##         y &lt;- as.matrix(y)
##     if (is.data.frame(x)) 
##         x &lt;- as.matrix(x)
##     if (!is.matrix(x) &amp;&amp; is.null(y)) 
##         stop(&quot;supply both &#39;x&#39; and &#39;y&#39; or a matrix-like &#39;x&#39;&quot;)
##     if (!(is.numeric(x) || is.logical(x))) 
##         stop(&quot;&#39;x&#39; must be numeric&quot;)
##     stopifnot(is.atomic(x))
##     if (!is.null(y)) {
##         if (!(is.numeric(y) || is.logical(y))) 
##             stop(&quot;&#39;y&#39; must be numeric&quot;)
##         stopifnot(is.atomic(y))
##     }
##     Rank &lt;- function(u) {
##         if (length(u) == 0L) 
##             u
##         else if (is.matrix(u)) {
##             if (nrow(u) &gt; 1L) 
##                 apply(u, 2L, rank, na.last = &quot;keep&quot;)
##             else row(u)
##         }
##         else rank(u, na.last = &quot;keep&quot;)
##     }
##     if (method == &quot;pearson&quot;) 
##         .Call(C_cor, x, y, na.method, FALSE)
##     else if (na.method %in% c(2L, 5L)) {
##         if (is.null(y)) {
##             .Call(C_cor, Rank(na.omit(x)), NULL, na.method, method == 
##                 &quot;kendall&quot;)
##         }
##         else {
##             nas &lt;- attr(na.omit(cbind(x, y)), &quot;na.action&quot;)
##             dropNA &lt;- function(x, nas) {
##                 if (length(nas)) {
##                   if (is.matrix(x)) 
##                     x[-nas, , drop = FALSE]
##                   else x[-nas]
##                 }
##                 else x
##             }
##             .Call(C_cor, Rank(dropNA(x, nas)), Rank(dropNA(y, 
##                 nas)), na.method, method == &quot;kendall&quot;)
##         }
##     }
##     else if (na.method != 3L) {
##         x &lt;- Rank(x)
##         if (!is.null(y)) 
##             y &lt;- Rank(y)
##         .Call(C_cor, x, y, na.method, method == &quot;kendall&quot;)
##     }
##     else {
##         if (is.null(y)) {
##             ncy &lt;- ncx &lt;- ncol(x)
##             if (ncx == 0) 
##                 stop(&quot;&#39;x&#39; is empty&quot;)
##             r &lt;- matrix(0, nrow = ncx, ncol = ncy)
##             for (i in seq_len(ncx)) {
##                 for (j in seq_len(i)) {
##                   x2 &lt;- x[, i]
##                   y2 &lt;- x[, j]
##                   ok &lt;- complete.cases(x2, y2)
##                   x2 &lt;- rank(x2[ok])
##                   y2 &lt;- rank(y2[ok])
##                   r[i, j] &lt;- if (any(ok)) 
##                     .Call(C_cor, x2, y2, 1L, method == &quot;kendall&quot;)
##                   else NA
##                 }
##             }
##             r &lt;- r + t(r) - diag(diag(r))
##             rownames(r) &lt;- colnames(x)
##             colnames(r) &lt;- colnames(x)
##             r
##         }
##         else {
##             if (length(x) == 0L || length(y) == 0L) 
##                 stop(&quot;both &#39;x&#39; and &#39;y&#39; must be non-empty&quot;)
##             matrix_result &lt;- is.matrix(x) || is.matrix(y)
##             if (!is.matrix(x)) 
##                 x &lt;- matrix(x, ncol = 1L)
##             if (!is.matrix(y)) 
##                 y &lt;- matrix(y, ncol = 1L)
##             ncx &lt;- ncol(x)
##             ncy &lt;- ncol(y)
##             r &lt;- matrix(0, nrow = ncx, ncol = ncy)
##             for (i in seq_len(ncx)) {
##                 for (j in seq_len(ncy)) {
##                   x2 &lt;- x[, i]
##                   y2 &lt;- y[, j]
##                   ok &lt;- complete.cases(x2, y2)
##                   x2 &lt;- rank(x2[ok])
##                   y2 &lt;- rank(y2[ok])
##                   r[i, j] &lt;- if (any(ok)) 
##                     .Call(C_cor, x2, y2, 1L, method == &quot;kendall&quot;)
##                   else NA
##                 }
##             }
##             rownames(r) &lt;- colnames(x)
##             colnames(r) &lt;- colnames(y)
##             if (matrix_result) 
##                 r
##             else drop(r)
##         }
##     }
## }
## &lt;bytecode: 0x00000000184249a8&gt;
## &lt;environment: namespace:stats&gt;
</code></pre>

<h2>Random Forest</h2>

<pre><code class="r">library(randomForest)
</code></pre>

<pre><code>## Error in library(randomForest): there is no package called &#39;randomForest&#39;
</code></pre>

<pre><code class="r">## fitting with train data
fitRF &lt;- randomForest(classe ~ ., data=Training, method=&quot;class&quot;)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): could not find function &quot;randomForest&quot;
</code></pre>

<pre><code class="r">PredictRF &lt;- predict(fitRF, type=&quot;class&quot;)
</code></pre>

<pre><code>## Error in predict(fitRF, type = &quot;class&quot;): object &#39;fitRF&#39; not found
</code></pre>

<pre><code class="r">confusionMatrix(Training$classe,PredictRF)
</code></pre>

<pre><code>## Error in confusionMatrix(Training$classe, PredictRF): object &#39;Training&#39; not found
</code></pre>

<pre><code class="r">table(Training$classe, PredictRF)
</code></pre>

<pre><code>## Error in table(Training$classe, PredictRF): object &#39;Training&#39; not found
</code></pre>

<pre><code class="r">nright = table(PredictRF == Training$classe)
</code></pre>

<pre><code>## Error in table(PredictRF == Training$classe): object &#39;PredictRF&#39; not found
</code></pre>

<pre><code class="r">nright
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;nright&#39; not found
</code></pre>

<pre><code class="r">ForestInError = as.vector(100 * (1-nright[&quot;TRUE&quot;] / sum(nright)))
</code></pre>

<pre><code>## Error in as.vector(100 * (1 - nright[&quot;TRUE&quot;]/sum(nright))): object &#39;nright&#39; not found
</code></pre>

<pre><code class="r">ForestInError 
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;ForestInError&#39; not found
</code></pre>

<pre><code class="r">varImpPlot(fitRF, sort = TRUE,  main = &quot;Importance of the Predictors&quot;)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): could not find function &quot;varImpPlot&quot;
</code></pre>

<pre><code class="r">## cross validating with 30% of train data
ValidateRF &lt;- predict(fitRF, newdata=TrainingTest, type=&quot;class&quot;)
</code></pre>

<pre><code>## Error in predict(fitRF, newdata = TrainingTest, type = &quot;class&quot;): object &#39;fitRF&#39; not found
</code></pre>

<pre><code class="r">confusionMatrix(TrainingTest$classe,ValidateRF)
</code></pre>

<pre><code>## Error in confusionMatrix(TrainingTest$classe, ValidateRF): object &#39;TrainingTest&#39; not found
</code></pre>

<pre><code class="r">nright = table(ValidateRF == TrainingTest$classe)
</code></pre>

<pre><code>## Error in table(ValidateRF == TrainingTest$classe): object &#39;ValidateRF&#39; not found
</code></pre>

<pre><code class="r">nright
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;nright&#39; not found
</code></pre>

<pre><code class="r">ForestInError = as.vector(100 * (1-nright[&quot;TRUE&quot;] / sum(nright)))
</code></pre>

<pre><code>## Error in as.vector(100 * (1 - nright[&quot;TRUE&quot;]/sum(nright))): object &#39;nright&#39; not found
</code></pre>

<pre><code class="r">ForestInError 
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;ForestInError&#39; not found
</code></pre>

<p>The random forest algorithm generates a model with accuracy 0.9913. The out-of-sample error is 0.9%, which is pretty low. We don’t need to go back and include more variables with imputations. The top 4 most important variables according to the model fit are ‘roll_belt’, ‘yaw_belt’, ‘pitch_forearm’ and ‘pitch_belt’.</p>

<h2>Regression Trees</h2>

<pre><code class="r">library(tree)
</code></pre>

<pre><code>## Error in library(tree): there is no package called &#39;tree&#39;
</code></pre>

<pre><code class="r">#fitting the model
fitTree &lt;- tree(classe ~ ., method=&quot;tree&quot;, data=Training)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): could not find function &quot;tree&quot;
</code></pre>

<pre><code class="r">PredictTree &lt;- predict(fitTree, type=&quot;class&quot;)
</code></pre>

<pre><code>## Error in predict(fitTree, type = &quot;class&quot;): object &#39;fitTree&#39; not found
</code></pre>

<pre><code class="r">table(Training$classe, PredictTree)
</code></pre>

<pre><code>## Error in table(Training$classe, PredictTree): object &#39;Training&#39; not found
</code></pre>

<pre><code class="r">fitTree.prune &lt;- prune.misclass(fitTree, best=10)
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): could not find function &quot;prune.misclass&quot;
</code></pre>

<pre><code class="r">#plot of generated tree
plot(fitTree.prune)
</code></pre>

<pre><code>## Error in plot(fitTree.prune): object &#39;fitTree.prune&#39; not found
</code></pre>

<pre><code class="r">title(main=&quot;Tree created using tree function&quot;)
</code></pre>

<pre><code>## Error in title(main = &quot;Tree created using tree function&quot;): plot.new has not been called yet
</code></pre>

<pre><code class="r">text(fitTree.prune, cex=1.2)
</code></pre>

<pre><code>## Error in text(fitTree.prune, cex = 1.2): object &#39;fitTree.prune&#39; not found
</code></pre>

<pre><code class="r">nright = table(PredictTree == Training$classe)
</code></pre>

<pre><code>## Error in table(PredictTree == Training$classe): object &#39;PredictTree&#39; not found
</code></pre>

<pre><code class="r">TreeInError = as.vector(100 * (1 - nright[&quot;TRUE&quot;] / sum(nright)))
</code></pre>

<pre><code>## Error in as.vector(100 * (1 - nright[&quot;TRUE&quot;]/sum(nright))): object &#39;nright&#39; not found
</code></pre>

<pre><code class="r">TreeInError 
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;TreeInError&#39; not found
</code></pre>

<pre><code class="r">#cross validating the model 30% data
ValidateTree &lt;- predict(fitTree, newdata = TrainingTest, type=&quot;class&quot;)
</code></pre>

<pre><code>## Error in predict(fitTree, newdata = TrainingTest, type = &quot;class&quot;): object &#39;fitTree&#39; not found
</code></pre>

<pre><code class="r">table(TrainingTest$classe, ValidateTree)
</code></pre>

<pre><code>## Error in table(TrainingTest$classe, ValidateTree): object &#39;TrainingTest&#39; not found
</code></pre>

<pre><code class="r">nright = table(ValidateTree == TrainingTest$classe)
</code></pre>

<pre><code>## Error in table(ValidateTree == TrainingTest$classe): object &#39;ValidateTree&#39; not found
</code></pre>

<pre><code class="r">TreeInError  = as.vector(100 * (1 - nright[&quot;TRUE&quot;] / sum(nright)))
</code></pre>

<pre><code>## Error in as.vector(100 * (1 - nright[&quot;TRUE&quot;]/sum(nright))): object &#39;nright&#39; not found
</code></pre>

<pre><code class="r">TreeInError 
</code></pre>

<pre><code>## Error in eval(expr, envir, enclos): object &#39;TreeInError&#39; not found
</code></pre>

<pre><code class="r">##pruning to improve cross validation
error.cv &lt;- {Inf}
for (i in 2:19) {
    prune.data &lt;- prune.misclass(fitTree, best=i)
    pred.cv &lt;- predict(prune.data, newdata=TrainingTest, type=&quot;class&quot;)
    nright = table(pred.cv == TrainingTest$classe)
    error = as.vector(100 * ( 1- nright[&quot;TRUE&quot;] / sum(nright)))
    error.cv &lt;- c(error.cv, error) 
}
</code></pre>

<pre><code>## Error: could not find function &quot;prune.misclass&quot;
</code></pre>

<pre><code class="r">#error.cv
plot(error.cv, type = &quot;l&quot;, xlab=&quot;Size of tree (number of nodes)&quot;, ylab=&quot;Out of sample error(%)&quot;, main = &quot;Relationship between tree size and out of sample error&quot;)
</code></pre>

<pre><code>## Warning in min(x): no non-missing arguments to min; returning Inf
</code></pre>

<pre><code>## Warning in max(x): no non-missing arguments to max; returning -Inf
</code></pre>

<pre><code>## Error in plot.window(...): need finite &#39;ylim&#39; values
</code></pre>

<p>Despite the complexity of the tree, the above fifures does not indicate overfitting as the out of sample error does not increase as more nodes are added to the tree.</p>

<h2>Results</h2>

<p>The random forest clearly performs better, approaching 99% accuracy for in-sample and out-of-sample error so we will select this model and apply it to the test data set. We use the provided function to classify 20 data points from the test set by the type of lift. </p>

<pre><code class="r">pml_write_files = function(x){
  n = length(x)
  for(i in 1:n){
    filename = paste0(&quot;problem_id_&quot;,i,&quot;.txt&quot;)
    write.table(x[i],file=filename,quote=FALSE,row.names=FALSE,col.names=FALSE)
  }
}


TestFit &lt;- predict(fitRF, newdata=Testing, type=&quot;class&quot;)
</code></pre>

<pre><code>## Error in predict(fitRF, newdata = Testing, type = &quot;class&quot;): object &#39;fitRF&#39; not found
</code></pre>

<pre><code class="r">pml_write_files(TestFit)
</code></pre>

<pre><code>## Error in pml_write_files(TestFit): object &#39;TestFit&#39; not found
</code></pre>

<h2>Conclusion</h2>

<p>We see Random Forest is the most rebost for this set.</p>

</body>

</html>
